/**
 * PR Comment Builder
 *
 * Generates markdown for PR comments with design review information
 */

import {
  CommentData,
  PenFileCommentData,
  FrameCommentData,
  CommentSummary,
  FileStatus,
  DiffFileCommentData,
  DiffCommentData,
  DiffCommentSummary,
} from './types';
import { createArtifactsSummary } from './github/artifacts';

// Unique identifier for our comments (for upsert logic)
export const COMMENT_MARKER = '<!-- pencil-design-review -->';

/**
 * Build a namespaced comment marker. When commentId is provided,
 * the marker includes it so multiple workflows can post separate comments.
 */
export function getCommentMarker(commentId?: string): string {
  if (commentId) {
    return `<!-- pencil-design-review:${commentId} -->`;
  }
  return COMMENT_MARKER;
}

/**
 * Escape markdown special characters in user-controlled strings
 */
function escapeMarkdown(text: string): string {
  return text.replace(/[[\]()|\\_*`~#>!]/g, '\\$&');
}

/**
 * Build the full PR comment markdown
 */
export function buildComment(data: CommentData, commentId?: string): string {
  const marker = getCommentMarker(commentId);
  const lines: string[] = [
    marker,
    '',
    '## üé® Design Review',
    '',
    buildSummarySection(data.summary),
    '',
  ];

  // Add each file section
  for (const file of data.files) {
    lines.push(buildFileSection(file));
    lines.push('');
  }

  // Add artifact download link
  const artifactLink = createArtifactsSummary(data.artifactUrl, data.summary.successfulRenders);
  if (artifactLink) {
    lines.push(artifactLink);
    lines.push('');
  }

  // Add footer
  lines.push('---');
  lines.push(buildFooter(data.commitSha));

  return lines.join('\n');
}

/**
 * Build the summary section
 */
function buildSummarySection(summary: CommentSummary): string {
  const parts: string[] = [];

  if (summary.addedFiles > 0) {
    parts.push(`**${summary.addedFiles}** added`);
  }
  if (summary.modifiedFiles > 0) {
    parts.push(`**${summary.modifiedFiles}** modified`);
  }
  if (summary.deletedFiles > 0) {
    parts.push(`**${summary.deletedFiles}** deleted`);
  }

  const filesSummary = parts.length > 0 ? parts.join(', ') : 'No changes';

  const lines = [
    `üìÅ **${summary.totalFiles}** design file${summary.totalFiles !== 1 ? 's' : ''} (${filesSummary})`,
    `üñºÔ∏è **${summary.totalFrames}** frame${summary.totalFrames !== 1 ? 's' : ''} detected`,
  ];

  if (summary.successfulRenders > 0) {
    lines.push(`‚úÖ **${summary.successfulRenders}** rendered successfully`);
  }

  if (summary.failedRenders > 0) {
    lines.push(`‚ùå **${summary.failedRenders}** failed to render`);
  }

  return lines.join('\n');
}

/**
 * Build section for a single file
 */
function buildFileSection(file: PenFileCommentData): string {
  const statusIcon = getStatusIcon(file.status);
  const statusLabel = getStatusLabel(file.status);

  const lines: string[] = [
    `### ${statusIcon} \`${file.path}\` (${statusLabel})`,
    '',
  ];

  if (file.frames.length === 0) {
    lines.push('_No frames found in this file_');
    return lines.join('\n');
  }

  // Check if we have any screenshots (visual mode)
  const hasScreenshots = file.frames.some(f => f.screenshotUrl || f.screenshotPath);

  if (hasScreenshots) {
    // Visual mode: show screenshots
    for (const frame of file.frames) {
      lines.push(buildFrameWithScreenshot(frame));
      lines.push('');
    }
  } else {
    // Metadata mode: show table
    lines.push(buildFrameTable(file.frames));
  }

  return lines.join('\n');
}

/**
 * Build a frame section with screenshot (visual mode)
 */
function buildFrameWithScreenshot(frame: FrameCommentData): string {
  const lines: string[] = [];

  lines.push(`#### ${escapeMarkdown(frame.name)}`);

  if (frame.error) {
    lines.push(`> ‚ö†Ô∏è Failed to render: ${escapeMarkdown(frame.error)}`);
  } else if (frame.screenshotUrl) {
    lines.push(`![${escapeMarkdown(frame.name)}](${frame.screenshotUrl})`);
  } else if (frame.screenshotPath) {
    // If we have a path but no URL, show the path as reference
    lines.push(`> Screenshot saved to: \`${frame.screenshotPath}\``);
  }

  return lines.join('\n');
}

/**
 * Build a table of frames (fallback for render failures)
 */
function buildFrameTable(frames: FrameCommentData[]): string {
  const lines: string[] = [
    '| Frame | ID | Status |',
    '|-------|-----|--------|',
  ];

  for (const frame of frames) {
    const status = frame.error ? `‚ùå ${escapeMarkdown(frame.error)}` : '‚úÖ OK';
    lines.push(`| ${escapeMarkdown(frame.name)} | \`${frame.id}\` | ${status} |`);
  }

  return lines.join('\n');
}

/**
 * Build the footer
 */
function buildFooter(commitSha: string): string {
  const shortSha = commitSha.substring(0, 7);
  return `_Generated by [Pencil Design Review](https://github.com/remotestate/pencil-actions) for commit ${shortSha}_`;
}

/**
 * Get icon for file status
 */
function getStatusIcon(status: FileStatus): string {
  switch (status) {
    case 'added':
      return 'üÜï';
    case 'modified':
      return 'üìù';
    case 'deleted':
      return 'üóëÔ∏è';
    case 'renamed':
      return 'üìã';
    default:
      return 'üìÑ';
  }
}

/**
 * Get label for file status
 */
function getStatusLabel(status: FileStatus): string {
  switch (status) {
    case 'added':
      return 'added';
    case 'modified':
      return 'modified';
    case 'deleted':
      return 'deleted';
    case 'renamed':
      return 'renamed';
    default:
      return 'changed';
  }
}

/**
 * Calculate summary statistics from file data
 */
export function calculateSummary(files: PenFileCommentData[]): CommentSummary {
  let totalFrames = 0;
  let successfulRenders = 0;
  let failedRenders = 0;
  let addedFiles = 0;
  let modifiedFiles = 0;
  let deletedFiles = 0;

  for (const file of files) {
    totalFrames += file.frames.length;

    for (const frame of file.frames) {
      if (frame.error) {
        failedRenders++;
      } else {
        successfulRenders++;
      }
    }

    switch (file.status) {
      case 'added':
        addedFiles++;
        break;
      case 'modified':
        modifiedFiles++;
        break;
      case 'deleted':
        deletedFiles++;
        break;
    }
  }

  return {
    totalFiles: files.length,
    totalFrames,
    successfulRenders,
    failedRenders,
    addedFiles,
    modifiedFiles,
    deletedFiles,
  };
}

/**
 * Build a minimal comment for when there are no design changes
 */
export function buildNoChangesComment(commentId?: string): string {
  const marker = getCommentMarker(commentId);
  return [
    marker,
    '',
    '## üé® Design Review',
    '',
    '_No `.pen` design files were changed in this PR._',
    '',
  ].join('\n');
}

// ‚îÄ‚îÄ Diff mode comment building ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Build a diff-mode PR comment.
 */
export function buildDiffComment(data: DiffCommentData, commentId?: string): string {
  const marker = getCommentMarker(commentId);
  const lines: string[] = [
    marker,
    '',
    '## üé® Design Review',
    '',
    buildDiffSummarySection(data.summary),
    '',
  ];

  for (const file of data.files) {
    lines.push(buildDiffFileSection(file, data.serviceUrl));
    lines.push('');
  }

  // Add artifact download link
  const totalRendered = data.summary.totalAddedFrames + data.summary.totalModifiedFrames;
  const artifactLink = createArtifactsSummary(data.artifactUrl, totalRendered);
  if (artifactLink) {
    lines.push(artifactLink);
    lines.push('');
  }

  lines.push('---');
  lines.push(buildFooter(data.commitSha));
  return lines.join('\n');
}

/**
 * Build the summary section for diff mode.
 */
function buildDiffSummarySection(summary: DiffCommentSummary): string {
  const fileParts: string[] = [];
  if (summary.addedFiles > 0) fileParts.push(`**${summary.addedFiles}** added`);
  if (summary.modifiedFiles > 0) fileParts.push(`**${summary.modifiedFiles}** modified`);
  if (summary.deletedFiles > 0) fileParts.push(`**${summary.deletedFiles}** deleted`);
  const filesSummary = fileParts.length > 0 ? fileParts.join(', ') : 'No changes';

  const lines = [
    `üìÅ **${summary.totalFiles}** design file${summary.totalFiles !== 1 ? 's' : ''} (${filesSummary})`,
  ];

  const frameParts: string[] = [];
  if (summary.totalAddedFrames > 0) frameParts.push(`**${summary.totalAddedFrames}** added`);
  if (summary.totalModifiedFrames > 0) frameParts.push(`**${summary.totalModifiedFrames}** modified`);
  if (summary.totalRemovedFrames > 0) frameParts.push(`**${summary.totalRemovedFrames}** removed`);
  if (summary.totalUnchangedFrames > 0) frameParts.push(`**${summary.totalUnchangedFrames}** unchanged`);

  if (frameParts.length > 0) {
    lines.push(`üñºÔ∏è Frames: ${frameParts.join(', ')}`);
  }

  return lines.join('\n');
}

/**
 * Build section for a single file in diff mode.
 */
function buildDiffFileSection(file: DiffFileCommentData, serviceUrl?: string): string {
  const statusIcon = getStatusIcon(file.status);
  const statusLabel = getStatusLabel(file.status);

  const lines: string[] = [
    `### ${statusIcon} \`${file.path}\` (${statusLabel})`,
    '',
  ];

  if (file.error) {
    lines.push(`> ‚ö†Ô∏è Error: ${escapeMarkdown(file.error)}`);
    return lines.join('\n');
  }

  if (file.status === 'deleted') {
    lines.push('_This design file was deleted._');
    return lines.join('\n');
  }

  // Added files: show frames with screenshots (same as full mode)
  if (file.status === 'added' && file.frames) {
    for (const frame of file.frames) {
      lines.push(buildFrameWithScreenshot(frame));
      lines.push('');
    }
    return lines.join('\n');
  }

  // Modified/renamed files: show diff sections
  if (file.diff) {
    const diff = file.diff;

    // Added frames section
    if (diff.added.length > 0) {
      lines.push('#### üÜï Added Frames');
      lines.push('');
      for (const frame of diff.added) {
        lines.push(`**${escapeMarkdown(frame.frameName)}**`);
        lines.push(`![${escapeMarkdown(frame.frameName)}](${frame.imageUrl})`);
        lines.push('');
      }
    }

    // Modified frames section (before/after)
    if (diff.modified.length > 0) {
      lines.push('#### ‚úèÔ∏è Modified Frames');
      lines.push('');
      for (const mod of diff.modified) {
        const compareUrl = serviceUrl && file.diff?.jobId
          ? `${serviceUrl}/compare/${file.diff.jobId}?frame=${encodeURIComponent(mod.frameName)}`
          : null;
        lines.push(
          compareUrl
            ? `**${escapeMarkdown(mod.frameName)}** ¬∑ [View full screen](${compareUrl})`
            : `**${escapeMarkdown(mod.frameName)}**`
        );
        lines.push('');
        lines.push('<table>');
        lines.push('<tr><th>Before</th><th>After</th></tr>');
        lines.push('<tr>');
        lines.push(`<td><img src="${mod.base.imageUrl}" alt="Before" /></td>`);
        lines.push(`<td><img src="${mod.head.imageUrl}" alt="After" /></td>`);
        lines.push('</tr>');
        lines.push('</table>');
        lines.push('');
      }
    }

    // Removed frames section
    if (diff.removed.length > 0) {
      lines.push('#### üóëÔ∏è Removed Frames');
      lines.push('');
      for (const frame of diff.removed) {
        lines.push(`- ~~${escapeMarkdown(frame.frameName)}~~ (\`${frame.frameId}\`)`);
      }
      lines.push('');
    }

    // Unchanged frames (collapsed)
    if (diff.unchanged.length > 0) {
      lines.push(`<details><summary>‚úÖ ${diff.unchanged.length} unchanged frame${diff.unchanged.length !== 1 ? 's' : ''}</summary>`);
      lines.push('');
      for (const frame of diff.unchanged) {
        lines.push(`- ${escapeMarkdown(frame.frameName)} (\`${frame.frameId}\`)`);
      }
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }

    // No changes at all
    if (diff.added.length === 0 && diff.modified.length === 0 && diff.removed.length === 0) {
      lines.push('_No frame-level changes detected._');
    }
  }

  return lines.join('\n');
}

/**
 * Calculate summary statistics for diff mode.
 */
export function calculateDiffSummary(files: DiffFileCommentData[]): DiffCommentSummary {
  let addedFiles = 0, modifiedFiles = 0, deletedFiles = 0;
  let totalAddedFrames = 0, totalModifiedFrames = 0, totalRemovedFrames = 0, totalUnchangedFrames = 0;

  for (const file of files) {
    switch (file.status) {
      case 'added': addedFiles++; break;
      case 'modified': case 'renamed': modifiedFiles++; break;
      case 'deleted': deletedFiles++; break;
    }

    if (file.diff) {
      totalAddedFrames += file.diff.summary.added;
      totalModifiedFrames += file.diff.summary.modified;
      totalRemovedFrames += file.diff.summary.removed;
      totalUnchangedFrames += file.diff.summary.unchanged;
    }

    // Added files rendered in full mode contribute to "added" count
    if (file.status === 'added' && file.frames) {
      totalAddedFrames += file.frames.filter(f => !f.error).length;
    }
  }

  return {
    totalFiles: files.length,
    addedFiles, modifiedFiles, deletedFiles,
    totalAddedFrames, totalModifiedFrames, totalRemovedFrames, totalUnchangedFrames,
  };
}
